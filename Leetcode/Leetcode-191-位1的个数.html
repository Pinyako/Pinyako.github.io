<hr>
<p>title: Leetcode 191.位1的个数<br>hidden: true<br>date: 2019-04-20 21:14:10<br>tags:</p>
<pre><code>- C++
- Leetcode
- 位运算
</code></pre><p>categories: Leetcode</p>
<h2 id="mathjax-false"><a href="#mathjax-false" class="headerlink" title="mathjax: false"></a>mathjax: false</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<p><strong>示例 1:</strong></p>
<pre><code class="lang-markdown">输入：00000000000000000000000000001011  
输出：3  
解释：输入的二进制串 00000000000000000000000000001011 中，&#39;1&#39;。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code class="lang-markdown">输入：00000000000000000000000010000000  
输出：1  
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code class="lang-markdown">输入：11111111111111111111111111111101  
输出：31  
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为&#39;1&#39;。
</code></pre>
<p><strong>进阶:</strong></p>
<blockquote>
<p>如果多次调用这个函数，你将如何优化你的算法？</p>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>可以循环的对输入数与1取与, 如结果为1则返回结果加1, 后右移1位.</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="lang-c++">class Solution { // 手动取每一位
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while(n != 0) {
            if(n&amp;1 == 1) ++count; // 如数和1取与为1则结果加1
            n &gt;&gt;=1;
        }
        return count;
    }
};
</code></pre>
<pre><code class="lang-c++">class Solution { // 使用STL的bitset
public:
    int hammingWeight(uint32_t n) {
        bitset&lt;32&gt; b(n);
        // 由于题中已说是32位无符号整数, 则可以使用bitset
        return b.count();
    }
};
</code></pre>
