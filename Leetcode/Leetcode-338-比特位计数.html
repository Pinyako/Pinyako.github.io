<hr>
<p>title: Leetcode 338.比特位计数<br>tags:</p>
<ul>
<li>hide</li>
<li>C++</li>
<li>Leetcode</li>
<li>动态规划<br>categories: Leetcode<br>mathjax: false<br>date: 2019-04-29 18:57:25</li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: 2<br>输出: [0,1,1]</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: 5<br>输出: [0,1,1,2,1,2]</p>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>假如某一个数的二进制1位数是n, 则它左移一位的数的1位数也是n, 这样我们便可以使用筛法来避免重复运算.</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="lang-c++">int finded[100000] = {0};

class Solution {
public:
    int dp(int num, int max) {
        if(finded[num] == 0) {
            int t = num, sum = 0;
            while(t != 0) {
                sum += t &amp; 1;
                t&gt;&gt;=1;
            }
            t = num;
            while(t &lt;= max) {
                finded[t] = sum;
                t &lt;&lt;= 1;
            }
        }
        return finded[num];
    }

    vector&lt;int&gt; countBits(int num) {
        vector&lt;int&gt; res;
        res.push_back(0);
        for(int i=1; i&lt;=num; ++i) {
            res.push_back(dp(i, num));
        }
        return res;
    }
};
</code></pre>
