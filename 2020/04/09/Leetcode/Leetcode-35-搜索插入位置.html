<hr>
<p>title: Leetcode 35.搜索插入位置<br>date: 2019-04-26 13:02:16<br>tags:</p>
<ul>
<li>hide<ul>
<li>C++</li>
<li>Leetcode<br>categories: Leetcode<br>mathjax: false</li>
</ul>
</li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<pre><code class="lang-markdown">输入: [1,3,5,6], 5
输出: 2
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code class="lang-markdown">输入: [1,3,5,6], 2
输出: 1
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code class="lang-markdown">输入: [1,3,5,6], 7
输出: 4
</code></pre>
<p><strong>示例 4:</strong></p>
<pre><code class="lang-markdown">输入: [1,3,5,6], 0
输出: 0
</code></pre>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>由于是有序数组, 则先比较目标数字与两侧极值的, 确定目标数字是否在数组之中, 而后从第一个元素开始迭代, 如果target &gt; nums[i] 并且 &lt;= nums[i+1]则返回i+1;</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="lang-c++">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        if(target &lt;= nums[0]) return 0;
        if(target &gt; nums[nums.size()-1]) return nums.size();
        if(target == nums[nums.size()-1]) return nums.size()-1;
        for(int i=0; i&lt;nums.size(); ++i) {
            if(nums[i] &lt; target &amp;&amp; nums[i+1] &gt;= target) return i+1;
        }
        return -1;
    }
};
</code></pre>
